-- vim: ft=sql expandtab

PARAMETERS
  -- Duration for which histograms are grown:
  obs_window DEFAULTS TO 350s,
  -- width of the histograms:
  nb_buckets DEFAULTS TO 20;

-- TODO: add the query / response sizes

DEFINE tcp_connections AS
  FROM ../../../csv/tcp
  WHERE ct_count > 0
  SELECT
    start,  -- approximation
    ct_count AS count,
    start + ct_sum / out.count{} AS stop,
    application,
    "TCP-Syn" AS protocol,
    string(ip_server) AS query,
    true AS success;

DEFINE tcp_generic AS
  FROM ../../../csv/tcp
  WHERE rt_count_server > 0
  SELECT
    start,
    rt_count_server AS count,
    start + rt_sum_server / out.count{} AS stop,
    application,
    "TCP-Gen" AS protocol,
    string(ip_server) AS query,
    true AS success;

DEFINE dns_resolutions AS
  FROM ../../../csv/dns WHERE
    query_type = 1 -- A
    OR query_type = 28 -- AAA
  SELECT
    start,
    rt_count_server AS count,
    start + rt_sum_server / out.count{} AS stop,
    application,
    "DNS" AS protocol,
    query_name || (IF query_type <> 1 THEN " (AAA)" ELSE "") AS query,
    error_count = 0 AS success;

DEFINE http_hits AS
  FROM ../../../csv/http
  WHERE resp_begin IS NOT NULL
  SELECT
    start,
    start + COALESCE(resp_begin, 0) - query_end AS stop,
    application,
    "HTTP" AS protocol,
    host || url AS query,
    NOT timeouted AND COALESCE(resp_code < 400, false) AS success,
    1 AS count;

DEFINE citrix_mix AS
  FROM ../../../csv/citrix,
       ../../../csv/citrix_chanless
  MERGE TIMEOUT AFTER 5s
  WHERE
    start > merge.greatest.start - 3min AND
    rt_count_server > 0
  SELECT
    start,
    rt_count_server AS count,
    start + rt_sum_server / out.count{} AS stop,
    application,
    "Citrix" AS protocol,
    COALESCE(username || "@", "") || domain ||
      COALESCE("(" || citrix_application || ")", "") AS query,
    true AS success;

DEFINE smb_mix AS
  FROM ../../../csv/smb
  WHERE resp_begin IS NOT NULL
  SELECT
    start,
    start + (COALESCE(resp_begin, 0) - query_end) AS stop,
    application,
    "SMB" AS protocol,
    COALESCE(user || "@", "") || domain || COALESCE(":" || path, "") AS query,
    COALESCE(status = 0, false) AS success, -- TODO
    1 AS count;

DEFINE sql_queries AS
  FROM ../../../csv/sql
  WHERE resp_begin IS NOT NULL
  SELECT
    start,
    start + COALESCE(resp_begin, 0) - query_end AS stop,
    application,
    "SQL" AS protocol,
    COALESCE(dbname ||": ", "") || query AS query,
    NOT is_error AS success,
    1 AS count;

-- TODO: We could have a group by application, protocol, success with an ongoing
-- TOP selecting for each group the worse queries, and then in the next node we
-- could aggregate per application, protocol, success and query.

DEFINE 'response times'
  "Aggregation of all possible queries/responses"
AS
  FROM
    tcp_connections,
    tcp_generic,
    dns_resolutions,
    http_hits,
    sql_queries,
    citrix_mix,
    smb_mix
  MERGE TIMEOUT AFTER 5s
  WHERE start > merge.greatest.start - 3min
  GROUP BY application, protocol, success, start // obs_window
  SELECT
    (start // obs_window) * obs_window AS start,
    out.start + obs_window AS stop,
    application, protocol,
    success DOC "Does the response indicate success?",
    SUM count AS count "Number of transactions."
    -- TODO: nb_buckets
    --HISTOGRAM(stop - start, 0, 30, 20) AS response_times
  -- Since we order the tuple according chronologically at input:
  COMMIT AFTER in.start > out.start + obs_window
  FACTORS application, protocol, success;
