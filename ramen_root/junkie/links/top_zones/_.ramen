-- vim: ft=sql expandtab
-- Track the top links of the cartesian product of zones, and aggregate
-- interesting metrics every minutes.  The "top" links are, for now, the
-- ones with the most distinct individual host-host pairings (approximate).

PARAMETERS
  top_size DEFAULT TO 100,
  top_duration DEFAULT TO 3600,
  aggr_duration DEFAULT TO 60;

-- We are going to sum tcp, udp, and all other metrics that together form
-- the whole traffic, wo that we can compute the volumetry. Unfortunately,
-- only TCP comes with any metric that bear any relation to quality of
-- service. We blanks these metrics for other sources below:

-- Shouldn't we be able to cram at least an RTT in here, from the many UDP
-- protocols that are supported?
DEFINE extended_udp AS
  FROM ../../../base/udp
  SELECT *,
    0u32 AS payload_packets_client,
    0u32 AS payload_packets_server,
    0u32n AS rtt_count_client,
    0u32n AS rtt_count_server,
    0u64 AS rtt_sum_client,
    0u64 AS rtt_sum_server,
    0u32n AS rd_count_client,
    0u32n AS rd_count_server;

-- Same here regarding RTT: isn't a ping response time essentially the
-- canonical way to measure RTT?
DEFINE extended_icmp AS
  FROM ../../../base/icmp
  SELECT *,
    0u32 AS payload_packets_client,
    0u32 AS payload_packets_server,
    0u64 AS payload_bytes_client,
    0u64 AS payload_bytes_server,
    0u32n AS rtt_count_client,
    0u32n AS rtt_count_server,
    0u64 AS rtt_sum_client,
    0u64 AS rtt_sum_server,
    0u32n AS rd_count_client,
    0u32n AS rd_count_server;

-- These, on the other hand, are more legit dark matter:
DEFINE extended_other_ip AS
  FROM '../../../base/other-ip'
  SELECT *,
    0u32 AS payload_packets_client,
    0u32 AS payload_packets_server,
    0u64 AS payload_bytes_client,
    0u64 AS payload_bytes_server,
    0u32n AS rtt_count_client,
    0u32n AS rtt_count_server,
    0u64 AS rtt_sum_client,
    0u64 AS rtt_sum_server,
    0u32n AS rd_count_client,
    0u32n AS rd_count_server;

DEFINE extended_non_ip AS
  FROM '../../../base/non-ip'
  SELECT *,
    0u32 AS payload_packets_client,
    0u32 AS payload_packets_server,
    0u64 AS payload_bytes_client,
    0u64 AS payload_bytes_server,
    0u32n AS rtt_count_client,
    0u32n AS rtt_count_server,
    0u64 AS rtt_sum_client,
    0u64 AS rtt_sum_server,
    0u32n AS rd_count_client,
    0u32n AS rd_count_server,
    u32(NULL) AS ip4_client,
    i128(NULL) AS ip6_client,
    u32(NULL) AS ip4_server,
    i128(NULL) AS ip6_server;

-- In c2s and s2c we have a unidirectional view of the traffic.
-- Here, we'd like to build a view where all the data concerning all
-- transferts bewtween Z1 and Z2 are in a single tuple.
-- We must then go back to the tcp/udp/icmp and other-ip tables, and
-- takes either client or server columns depending on whether zone_client
-- or ip_client is smaller.
DEFINE link_c2s AS
  FROM
    ../../../base/tcp,
    extended_udp,
    extended_icmp,
    extended_other_ip,
    extended_non_ip
  WHERE
    zone_client < zone_server OR
    zone_client = zone_server AND
    COALESCE(ip4_client, ip6_client, 0) <= COALESCE(ip4_server, ip6_server, 0)
  SELECT
    capture_begin / 1e6 AS start,
    capture_end / 1e6 AS stop,

    zone_client AS zone_1, zone_server AS zone_2,
    vlan_client AS vlan_1, vlan_server AS vlan_2,
    ip4_client AS ip4_1, ip6_client AS ip6_1,
    ip4_server AS ip4_2, ip6_server AS ip6_2,
    mtu_client AS mtu_1, mtu_server AS mtu_2,

    traffic_packets_client AS packets_1, traffic_packets_server AS packets_2,
    traffic_bytes_client AS bytes_1, traffic_bytes_server AS bytes_2,
    payload_packets_client AS packets_with_payload_1, payload_packets_server AS packets_with_payload_2,
    payload_bytes_client AS payload_1, payload_bytes_server AS payload_2,

    rtt_count_client AS rtt_count_1, rtt_count_server AS rtt_count_2,
    rtt_sum_client AS rtt_sum_1, rtt_sum_server AS rtt_sum_2,
    rd_count_client AS rd_count_1, rd_count_server AS rd_count_2
  EVENT STARTS AT start AND ENDS AT stop;

-- In the other way around for the other tuples:
DEFINE link_s2c AS
  FROM
    ../../../base/tcp,
    extended_udp,
    extended_icmp,
    extended_other_ip,
    extended_non_ip
  WHERE
    zone_server < zone_client OR
    zone_server = zone_client AND
    COALESCE(ip4_server, ip6_server, 0) < COALESCE(ip4_client, ip6_client, 0)
  SELECT
    capture_begin / 1e6 AS start,
    capture_end / 1e6 AS stop,

    zone_server AS zone_1, zone_client AS zone_2,
    vlan_server AS vlan_1, vlan_client AS vlan_2,
    ip4_server AS ip4_1, ip6_server AS ip6_1,
    ip4_client AS ip4_2, ip6_client AS ip6_2,
    mtu_server AS mtu_1, mtu_client AS mtu_2,

    traffic_packets_server AS packets_1, traffic_packets_client AS packets_2,
    traffic_bytes_server AS bytes_1, traffic_bytes_client AS bytes_2,
    payload_packets_server AS packets_with_payload_1, payload_packets_client AS packets_with_payload_2,
    payload_bytes_server AS payload_1, payload_bytes_client AS payload_2,

    rtt_count_server AS rtt_count_1, rtt_count_client AS rtt_count_2,
    rtt_sum_server AS rtt_sum_1, rtt_sum_client AS rtt_sum_2,
    rd_count_server AS rd_count_1, rd_count_client AS rd_count_2
  EVENT STARTS AT start AND ENDS AT stop;


-- This node merely computes the number of unique host-host connections, and
-- accordingly blanks the zone_src/dst.
-- The number of distinct pairs of hosts is approximated using a single large
-- rotating bloom filter.
DEFINE degraded AS
  FROM
    link_c2s, link_s2c
  MERGE ON start TIMEOUT AFTER 2 SECONDS
  SELECT
    *,
    REMEMBER globally (
      0.03, -- false positive rate
      start, -- time
      3600, -- memory duration
      -- What to remember:
      -- Notice we want to avoid remembering a nullable value.
      -- Also, in theory vlan_1 = vlan_2.
      COALESCE(vlan_1, vlan_2, 0),
      COALESCE(ip4_1, ip6_1, 0),
      COALESCE(ip4_2, ip6_2, 0)
    ) AS is_new_hosts_pair,
    -- nullifies the zones if not important:
    IS zone_1, zone_2 IN TOP top_size BY u32(is_new_hosts_pair)
      IN THE LAST top_duration AT TIME start AS _important,
    IF _important THEN zone_1 ELSE NULL AS zone_1,
    IF _important THEN zone_2 ELSE NULL AS zone_2;

-- Now that we have reduced that dimension, we can aggregate on
-- zone_1*zone_2
DEFINE top AS
  FROM degraded
  GROUP BY zone_1, zone_2
  SELECT
    -- Zone info
    zone_1,
    zone_2,
    sum u32(is_new_hosts_pair) AS host_pairs,

    -- Time info
    min start AS _min_start,
    (_min_start // aggr_duration) * aggr_duration AS start,

    -- Volumetry 1 -> 2
    sum packets_1 / aggr_duration AS packets_per_secs_1,
    sum bytes_1 / aggr_duration AS bytes_per_secs_1,
    sum payload_1 / aggr_duration AS payload_bytes_per_secs_1,
    -- Volumetry 2 -> 1
    sum packets_2 / aggr_duration AS packets_per_secs_2,
    sum bytes_2 / aggr_duration AS bytes_per_secs_2,
    sum payload_2 / aggr_duration AS payload_bytes_per_secs_2,

    -- RTT 1 -> 2 (in seconds)
    sum (rtt_sum_1 / 1e6) / sum rtt_count_1 AS avg_rtt_1,
    -- Also try to retain an idea of what the measured max avg had been:
    (rtt_sum_1 / 1e6) / rtt_count_1 AS _avg_rtt_1,
    min _avg_rtt_1,
    max _avg_rtt_1,
    -- RTT 2 -> 1
    sum (rtt_sum_2 / 1e6) / sum rtt_count_2 AS avg_rtt_2,
    (rtt_sum_2 / 1e6) / rtt_count_2 AS _avg_rtt_2,
    min _avg_rtt_2,
    max _avg_rtt_2,

    -- RR: percentage of retransmitted packets over packets with payload
    100 * sum rd_count_1 / sum packets_with_payload_1 AS avg_rr_1,
    -- Again, try to retain an idea of the max measured:
    100 * rd_count_1 / packets_with_payload_1 AS _avg_rr_1,
    min _avg_rr_1,
    max _avg_rr_1,
    -- RR 2 -> 1
    100 * sum rd_count_2 / sum packets_with_payload_2 AS avg_rr_2,
    -- Again, try to retain an idea of the max measured:
    100 * rd_count_2 / packets_with_payload_2 AS _avg_rr_2,
    min _avg_rr_2,
    max _avg_rr_2,

    -- Everything we can aggregate by zone:
    max mtu_1, max mtu_2

    -- TODO: other metrics, but need to be able to select fields present only
    -- in one parent (will be forced nullable and written as NULL by other
    -- parents) ; meanwhile we could also do it using converting nodes but
    -- that will be verbose and less efficient.

  COMMIT AFTER in.start > out.start + aggr_duration + 20s
  EVENT STARTS AT start WITH DURATION aggr_duration
  FACTORS zone_1, zone_2;
